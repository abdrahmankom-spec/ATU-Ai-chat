АТУ ПОРТАЛ — демонстрационный кампус на чистых HTML/CSS/JS. Ниже — компактные знания для RAG. Каждый факт упакован в блок `✦...◈`, чтобы поисковая система могла выбирать только нужные фрагменты.

======================================================================
0. ПРАВИЛА ДЛЯ RAG
======================================================================
✦RAG_RULES
1. Если ввод не похож на вопрос (приветствие, эмоция), отправь его модели без подсказок.
2. Если вопрос смешанный, собери несколько блоков и склей.
3. Пользовательские поля (имя, группа, программа, этаж) бери из `getUserContext()`, а остальное — из блоков ниже.
4. В ответе до 3 предложений, на русском, без ссылок и придуманных фактов. Если данных нет — скажи честно.
5. Не передавай больше 3 подсказок за раз; выбирай самые релевантные по смыслу.
◈

======================================================================
1. ПОРТАЛ И ОСНОВНЫЕ ФАЙЛЫ
======================================================================
✦PORTAL:Что это
- Главная сцена — `index.html`: параллакс, стены, шесть этажей, лифт, мини-ИИ.
- Дополнительные страницы этажей лежат в `pages/floor-1.html … floor-6.html`.
- Стили: `css/style.css` (основа), `css/page.css` (внутренние страницы), `css/dashboard.css` (дашборд).
- Скрипты: `js/bd.js` (данные и auth), `js/main.js` (анимации, UI), `js/page.js` (внутренние страницы).
◈
✦PORTAL:Как работает
- `bd.js` создаёт `window.DB`, управляет `localStorage` (`atu_db_users`, `atu_current_user`).
- `main.js` запускает параллакс, обновляет покрытия этажей, лифт, авторизацию, уведомления.
- `page.js` проверяет авторизацию на внутренних страницах, заполняет формы профиля, эдвайзера, расписания.
- Мини-ИИ (`.ai-chat`) подгружает `context.txt`, embeddings и модель ответов прямо в браузере.
◈

======================================================================
2. ХРАНИЛИЩЕ И АВТОРИЗАЦИЯ
======================================================================
✦AUTH:Структура данных
- `atu_db_users`: массив `{ name, pass, photo?, group, program, grades?, schedule? }`.
- `atu_current_user`: `{ name }` активного пользователя.
- Функции `DB`: `getUser`, `upsertUser`, `auth`, `logout`, `getCurrentUserObj`, `randomGroup`, `generateRandomGrades`, `generateScheduleForUser`, `compressImageToDataURL`.
◈
✦AUTH:Как работает
- Первое посещение: `atu_db_users` пуст → `syncAuthUI()` показывает `.toast-auth`, все `div.cover` непрозрачны.
- Регистрация через `#toast-login`: создаётся пользователь, к нему генерируются группа, программа «АТУ — бакалавриат», демо-оценки и расписание (7 дней вперёд, пары по 60 мин с перерывом 10 мин).
- Авторизация: `DB.auth` сверяет пароль, при успехе `DB.setCurrentUser` и `syncAuthUI()` обновляет профиль первого этажа.
- `#exit-profile` вызывает `DB.logout()` и возвращает состояние гостя.
◈

======================================================================
3. ГЛАВНАЯ СЦЕНА И АНИМАЦИИ
======================================================================
✦SCENE:Параллакс и стены
- `updateParallax()` каждую анимационную рамку сглаживает `smoothScroll += (scrollY - smoothScroll) * 0.1`.
- Слои: `.bg-img` (деление на -6), `.mid-img` (-10), `.mid-gradient` (-7.1 + постепенная opacity), `.top-img` (-5.7 + scale до 1.1).
- `div.divider` с `.pol-potolok` наклоняются в `updatePolPotolok()` по формуле `t = clamp((lineCenter - magnetY)/(vh*0.18), -1.2, 1.2)`; крайние угол ±70°.
- `updateFloorShadow()` даёт ближайшему этажу динамическую тень, `updateCovers()` оставляет прозрачным только этаж в центре экрана у авторизованного пользователя.
◈
✦SCENE:Structural элементы
- `.cover` — прозрачная плёнка, блокирующая этажи до входа.
- `.walls` и `.elevator` становятся видимыми, когда параллакс уже прокручен.
- Логика запускается в `main.js` после `DOMContentLoaded`, а затем крутится через `requestAnimationFrame(frame)`.
◈

======================================================================
4. ЛИФТ
======================================================================
✦ELEVATOR:Как устроен
- HTML: `.elevator` с кнопками `.elev-jump[data-floor=0…5]`, стрелками `.elev-up/.elev-down`, индикатором `#elev-floor` и подписью `.elev-floor-label`.
- `setupElevator()` собирает массив `section.floor`, читает их заголовки и хранит в `floorNames`.
- `currentFloorIndex()` ищет секцию, чья середина ближе всего к центру viewport.
- `gotoFloor(i)` выполняет `window.scrollTo({ top: floors[i].offsetTop + 1, behavior: 'smooth' })`.
- `syncUI()` обновляет номер (человеческий счёт 6→1), подпись и подсветку кнопок, подписан на `scroll` и `resize`.
- На ширине <768px блок переезжает вниз и становится горизонтальной панелью.
◈

======================================================================
5. ЭТАЖИ (КРАТКО)
======================================================================
✦FLOOR6:Дашборд
- Цвет `--hue: 210`, сетка `.dashboard-grid` из `.dash-card` с изображением и кнопкой на `pages/floor-6.html?page=...`.
- Внутренняя страница: `nav.sidebar` с гамбургером, `showPage(id)` включает нужную секцию.
- Таблица `#grades-table` подсвечивает оценки (<70 красный, >90 зелёный), `#subjects-list` и `#schedule-list` читают данные пользователя.
- Все данные подтягиваются из LocalStorage; при отсутствии сессии происходит редирект на `index.html`.
◈
✦FLOOR5:Новости и формы
- `.floor-news` содержит стеклянный блок `.news-content` и вертикальную `.news-grid` с карточками.
- JS каждые 7 секунд меняет фон через `div.news-fade-layer` и массив `.webp` изображений.
- На странице `floor-5.html` есть переключатели темы `#theme-toggle`, контактная форма с валидацией, мини ToDo и галерея; для плавной прокрутки используется Swiper@11 и кастомный `newsGridWheel()`.
◈
✦FLOOR4:Библиотека
- Карточка `article.floor-card` с кнопками-якорями на `pages/floor-4.html`.
- Внутри страницы — sticky навигация, разделы научных ресурсов, eLibrary/CyberLeninka/OpenEdu, рекомендации, FAQ разработчиков, контакты. Кнопка `#toTop` возвращает вверх при `scrollY>300`.
◈
✦FLOOR3:Учебный план
- Карточка отображает `user.program`, кнопка ведёт на `pages/floor-3.html`.
- На странице выпадающий список `#program-select` переключает предопределённый объект `PROGRAMS` (title, описание, таблица семестр/дисциплины/кредиты). При отсутствии данных показывается `#no-data`.
◈
✦FLOOR2:Мой эдвайзер
- Карточка показывает `#edviser-name`, кнопка на `pages/floor-2.html`.
- `page.js` ищет текущую группу пользователя, получает эдвайзера через `DB.getAdvisorForGroup`, заполняет `#adv-name/#adv-role/#adv-dept/#adv-field/#adv-contact` и фон `#adv-photo`.
◈
✦FLOOR1:Профиль
- Блок `.profile-info` отображает имя, группу, программу, кнопки «Настройки профиля» (`#profile-action`) и «Выйти` (`#exit-profile`); `.profile-photo` показывает `#img-user`.
- Страница `floor-1.html` позволяет редактировать имя, пароль, группу, программу, фото (через `DB.compressImageToDataURL`). Все изменения мгновенно сохраняются в `atu_db_users`.
◈

======================================================================
6. МИНИ-ИИ И RAG
======================================================================
✦AI:Инициализация
- Скрипт ждёт `window.transformers` (CDN @xenova/transformers 2.17.2) и `window.webllm`.
- `ensureResources()` последовательно выполняет: `fetch('context.txt')`, загрузку embeddings `pipeline('feature-extraction','Xenova/all-MiniLM-L6-v2',{ quantized:true })`, поднятие WebLLM (`CreateEngine` с `Phi2-q4f32_1-1k`, IndexedDB cache).
- При успехе разблокирует кнопку отправки, показывает уведомление «ИИ-помощник готов!» и включает звук `media/new-notification-09-352705.mp3` (если пользователь разрешил аудио).
◈
✦AI:RAG-процесс
- `getUserContext()` читает LocalStorage и формирует строку «Имя, группа, программа, активный этаж лифта».
- `context.txt` индексируется на блоки и нарезается на фрагменты; при вопросе вычисляется embedding пользователя и подбирается до трёх релевантных подсказок.
- WebLLM получает системное сообщение (краткие правила), блок `RAG SUMMARY` и текст пользователя. Ограничение генерации — 120 токенов.
- Ответ очищается от ссылок, `@`, `#` и случайных артефактов перед показом.
◈

======================================================================
7. КОМАНДЫ БОТА
======================================================================
✦COMMANDS:Список
- `/clear` (или текст "очистить хранилище", "дроп базу") → чистит LocalStorage и IndexedDB, затем перезагружает страницу после подтверждения.
- `/reload` → перезагружает страницу через 1 секунду после подтверждения.
- `/dashboard`, `/library`, `/profile` → переходы на `pages/floor-6.html`, `pages/floor-5.html`, `pages/floor-1.html` соответственно; требуют подтверждения в чате.
- Подтверждать можно кнопкой «Да/Нет» либо текстом («да», «нет»). После действия `pendingCommand` сбрасывается.
◈

======================================================================
8. ДАННЫЕ И ПОЛЕЗНЫЕ СВЯЗКИ
======================================================================
✦DATA:Структуры и генераторы
- Пользовательский объект хранит оценки (словарь предмет → 50..100), расписание (массив `{ subject, date, startTime, endTime }` без выходных, начало 08:30, перерывы 10 мин).
- `DB.generateRandomGrades()` выбирает дисциплины из `DB.SUBJECTS` (12 названий).
- `DB.generateScheduleForUser()` создаёт 3–5 пар в день, не позже 17:00, гарантирует, что `user.grades` заполнен.
- Эдвайзеры описаны в `DB.ADVISORS`, соответствия групп — в `DB.GROUP_ADVISORS`.
◈
✦SCENARIOS:Жизненные потоки
1. Загрузка страницы → `bd.js` инициализирует базу → `main.js` запускает анимации и авторизацию → новости и мини-ИИ подготавливаются.
2. Регистрация/логин → `DB.upsertUser` → `DB.setCurrentUser` → `syncAuthUI()` снимает покрытия, обновляет профиль.
3. Переход на этаж → лифт или скролл → `updateCovers()` и `updateFloorShadow()` подсвечивают нужный блок → кнопка ведёт на соответствующую страницу.
4. Работа ИИ → текст пользователя → проверка команд → RAG выбирает подсказки → WebLLM отвечает → `appendMessage()` показывает результат.
◈

======================================================================
9. ПРИМЕРЫ ПОЛЕЗНЫХ ФАКТОВ
======================================================================
✦FACTS:Быстрые ответы
- Этажи защищены, пока пользователь не авторизован, благодаря `div.cover`.
- Лифт показывает номера в обратном порядке (верхний этаж = 6, нижний = 1), потому что массив этажей идёт сверху вниз.
- Параллакс и стены автоматически отключаются на устройствах уже 768 px по ширине, чтобы экономить ресурсы.
- Мини-ИИ работает полностью офлайн: модели и веса кэшируются в IndexedDB и не требуют сервера.
◈

======================================================================
10. WEBLLM И ТЕХНОЛОГИЯ НЕЙРОСЕТИ
======================================================================
✦WEBLLM:Что это
- WebLLM — библиотека от MLC AI (`@mlc-ai/web-llm` версия 0.2.36), которая запускает большие языковые модели прямо в браузере через WebGPU.
- Модель работает полностью офлайн, без сервера: веса скачиваются с HuggingFace и кэшируются в IndexedDB для повторного использования.
- Используемая модель: `Phi2-q4f32_1-1k` (Phi-2 от Microsoft, квантизация 4-bit, контекстное окно 1k токенов, ~2.7 ГБ VRAM).
- WebLLM совместим с OpenAI API, поэтому чат использует стандартный формат `chat.completions.create()` с системными сообщениями и историей.
◈
✦WEBLLM:Как работает
- Инициализация: `webllm.CreateEngine(modelId, { initProgressCallback, appConfig })` загружает WASM-библиотеку модели, токенизатор, веса и конфигурацию чата.
- Кэширование: `appConfig.useIndexedDBCache: true` сохраняет все артефакты (веса, конфиги, WASM) в IndexedDB, чтобы при следующем запуске не скачивать заново.
- Генерация: движок принимает массив сообщений `[{ role: 'system', content: '...' }, { role: 'user', content: '...' }]`, параметры `temperature: 0.45, top_p: 0.85, max_tokens: 120` и возвращает объект с `choices[0].message.content`.
- Ограничения: модель имеет контекстное окно 1000 токенов, поэтому промпты обрезаются до 600 символов, а генерация ограничена 120 токенами, чтобы не переполнить KV-кэш.
◈
✦WEBLLM:Технические детали
- WebGPU: модель использует WebGPU для ускорения вычислений на GPU пользователя (если доступно), иначе падает на CPU.
- Полифилл: для Windows 10 добавлен полифилл `GPUAdapter.prototype.requestAdapterInfo`, так как API ещё экспериментальный.
- Загрузка: первая инициализация занимает 30–60 секунд (скачивание ~500 МБ весов), последующие запуски — 2–5 секунд (чтение из IndexedDB).
- Ошибки: при переполнении KV-кэша (`Exceed max window length`) модель аварийно завершается; для предотвращения промпты укорачиваются, а простые приветствия обрабатываются без вызова модели.
◈

======================================================================
11. RAG И EMBEDDINGS
======================================================================
✦RAG_TECH:Как устроен поиск
- Embeddings модель: `Xenova/all-MiniLM-L6-v2` (через CDN @xenova/transformers 2.17.2) преобразует текст в 384-мерные векторы для семантического поиска.
- Индексация: `context.txt` разбивается на блоки по разделителям `======================================================================`, каждый блок нарезается на фрагменты по 200–400 символов, для каждого вычисляется embedding и сохраняется в памяти.
- Поиск: при вопросе пользователя вычисляется embedding вопроса, затем косинусное сходство со всеми фрагментами; выбираются до 3 самых релевантных (порог >0.22).
- Формирование подсказки: найденные фрагменты склеиваются в блок `RAG SUMMARY`, который передаётся в WebLLM вместе с системным сообщением и вопросом пользователя.
◈
✦RAG_TECH:Оптимизации
- Ленивая загрузка: embeddings вычисляются только при первом вопросе, а не при загрузке страницы.
- Кэширование: посчитанные embeddings хранятся в памяти для повторного использования при следующих запросах.
- Умная фильтрация: простые приветствия и команды обрабатываются без RAG, чтобы не тратить ресурсы на очевидные ответы.
- Ограничение длины: каждый фрагмент обрезается до 600 символов, общая длина подсказок не превышает 1800 символов.
◈

======================================================================
12. JSON ФАЙЛЫ И КОНФИГУРАЦИЯ
======================================================================
✦JSON:package.json
- Файл `package.json` содержит единственную зависимость: `"@mlc-ai/web-llm": "^0.2.36"` — библиотека для запуска LLM в браузере.
- Установка через `npm install` создаёт `node_modules/@mlc-ai/web-llm/` с WASM-файлами, типами TypeScript и конфигурацией моделей.
- В продакшене библиотека загружается через CDN (`https://esm.run/@mlc-ai/web-llm@0.2.36`), поэтому `node_modules` не обязателен для работы сайта.
◈
✦JSON:package-lock.json
- Автоматически генерируемый файл, фиксирует точные версии зависимостей и их подзависимостей для воспроизводимых сборок.
- Не используется напрямую в браузере, нужен только для разработки и установки через `npm`.
◈
✦JSON:Данные в LocalStorage
- Хотя данные хранятся в LocalStorage как JSON-строки, они не являются отдельными файлами: `atu_db_users` и `atu_current_user` — это ключи в браузерном хранилище.
- Структура пользователя: `{ name, pass, photo?, group, program, grades?: { предмет: оценка }, schedule?: [{ subject, date, startTime, endTime }] }`.
- Все данные сериализуются через `JSON.stringify()` при записи и `JSON.parse()` при чтении.
◈
